import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useSocket } from '../../contexts/SocketContext';
import { useAdminAuth } from '../../auth/AdminAuthProvider';
import { toast } from 'react-toastify';
import { AiOutlinePaperClip, AiOutlineSend } from 'react-icons/ai';
import { BsCheckAll, BsCheck } from 'react-icons/bs';
import './AdminSupportChat.css';

const AdminSupportChat = () => {
  const { admin } = useAdminAuth();
  const socket = useSocket();
  const [chats, setChats] = useState([]);
  const [selectedChat, setSelectedChat] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [attachments, setAttachments] = useState([]);
  const [onlineUsers, setOnlineUsers] = useState(new Set());
  const [typingUsers, setTypingUsers] = useState(new Set());
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const [showSidebar, setShowSidebar] = useState(true);
  const messagesEndRef = useRef(null);
  const fileInputRef = useRef(null);
  const typingTimeoutRef = useRef(null);

  // Socket event handlers
  // Socket event handlers
  useEffect(() => {
    if (!socket) return;

    const onNewMessage = (message) => {
      if (selectedChat?._id === message.chatId) {
        setMessages(prev => [...prev, message]);
        socket.emit('admin:markMessagesRead', { chatId: selectedChat._id });
      }
      setChats(prev => prev.map(chat => {
        if (chat._id === message.chatId) {
          return {
            ...chat,
            lastMessage: message,
            unreadCount: selectedChat?._id === message.chatId ? 0 : (chat.unreadCount || 0) + 1
          };
        }
        return chat;
      }));
    };

    const onTyping = ({ chatId, userId }) => {
      setTypingUsers(prev => new Set(prev).add(userId));
    };

    const onStopTyping = ({ chatId, userId }) => {
      setTypingUsers(prev => {
        const newSet = new Set(prev);
        newSet.delete(userId);
        return newSet;
      });
    };

    const onUserOnline = (userId) => {
      setOnlineUsers(prev => new Set(prev).add(userId));
    };

    const onUserOffline = (userId) => {
      setOnlineUsers(prev => {
        const newSet = new Set(prev);
        newSet.delete(userId);
        return newSet;
      });
    };

    socket.on('message', onNewMessage);
    socket.on('typing', onTyping);
    socket.on('stopTyping', onStopTyping);
    socket.on('userOnline', onUserOnline);
    socket.on('userOffline', onUserOffline);

    return () => {
      socket.off('message', onNewMessage);
      socket.off('typing', onTyping);
      socket.off('stopTyping', onStopTyping);
      socket.off('userOnline', onUserOnline);
      socket.off('userOffline', onUserOffline);
    };
  }, [socket, selectedChat]);
    });

    socket.on('typing', ({ chatId, userId }) => {
      setTypingUsers(prev => new Set(prev).add(userId));
    });

    socket.on('stopTyping', ({ chatId, userId }) => {
      setTypingUsers(prev => {
        const newSet = new Set(prev);
        newSet.delete(userId);
        return newSet;
      });
    });

    socket.on('userOnline', (userId) => {
      setOnlineUsers(prev => new Set(prev).add(userId));
    });

    socket.on('userOffline', (userId) => {
      setOnlineUsers(prev => {
        const newSet = new Set(prev);
        newSet.delete(userId);
        return newSet;
      });
    });

    return () => {
      socket.off('message');
      socket.off('typing');
      socket.off('stopTyping');
      socket.off('userOnline');
      socket.off('userOffline');
    };
  }, [socket, selectedChat]);

  const categories = [
    { value: 'all', label: 'All Categories' },
    { value: 'general', label: 'General Inquiry' },
    { value: 'technical', label: 'Technical Support' },
    { value: 'billing', label: 'Billing & Payments' },
    { value: 'account', label: 'Account Issues' },
    { value: 'investment', label: 'Investment Questions' },
    { value: 'security', label: 'Security Concerns' },
    { value: 'feature', label: 'Feature Request' },
    { value: 'bug', label: 'Bug Report' }
  ];

  // initial data fetch and mobile detection are executed after fetch helpers are defined

  // fetchMessages and fetchTickets are called from the initial effect below
  // fetchMessages will be defined below; effect moved after its declaration to avoid use-before-define warnings

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleSearch = useCallback((searchTerm) => {
    if (!searchTerm.trim()) {
      return chats;
    }
    return chats.filter((chat) => 
      chat.userName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      chat.userEmail.toLowerCase().includes(searchTerm.toLowerCase()) ||
      chat.lastMessage?.content.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [chats]);

  const handleChatSelect = useCallback((chat) => {
    setSelectedChat(chat);
    if (isMobile) {
      setShowSidebar(false);
    }
    // Mark messages as read
    if (chat.unreadCount > 0) {
      socket.emit('admin:markMessagesRead', { chatId: chat._id });
    }
    // Fetch messages for this chat
    fetchMessages(chat._id);
  }, [isMobile, socket]);

  const handleInputChange = (e) => {
    setNewMessage(e.target.value);
    // Emit typing status
    if (selectedChat) {
      socket.emit('admin:typing', { chatId: selectedChat._id });
      // Clear previous timeout
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      // Set new timeout
      typingTimeoutRef.current = setTimeout(() => {
        socket.emit('admin:stopTyping', { chatId: selectedChat._id });
      }, 1000);
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const handleFileChange = (e) => {
    const files = Array.from(e.target.files);
    if (files.length > 5) {
      toast.error('You can only upload up to 5 files at once');
      return;
    }

    const totalSize = files.reduce((acc, file) => acc + file.size, 0);
    if (totalSize > 10 * 1024 * 1024) { // 10MB limit
      toast.error('Total file size must be less than 10MB');
      return;
    }

    setAttachments(files);
  };

  const handleSendMessage = async () => {
    if (!selectedChat || (!newMessage.trim() && !attachments.length)) {
      return;
    }

    try {
      // First, upload any attachments
      let uploadedFiles = [];
      if (attachments.length > 0) {
        const formData = new FormData();
        attachments.forEach(file => {
          formData.append('files', file);
        });

        const uploadResponse = await fetch('/api/uploads', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('adminToken')}`,
          },
          body: formData
        });

        if (uploadResponse.ok) {
          const data = await uploadResponse.json();
          uploadedFiles = data.files;
        }
      }

      // Now send the message with any attachments
      socket.emit('admin:message', {
        chatId: selectedChat._id,
        content: newMessage.trim(),
        attachments: uploadedFiles
      });

      setNewMessage('');
      setAttachments([]);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    } catch (error) {
      console.error('Error sending message:', error);
      toast.error('Failed to send message');
    }
  };
      }
    } catch (error) {
      console.error('Error fetching agents:', error);
    }
  }, []);

  const fetchChats = useCallback(async () => {
    try {
      const response = await fetch('/api/admin/chat/active', {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
        }
      });

      if (response.ok) {
        const data = await response.json();
        setChats(data.chats);
      }
    } catch (error) {
      console.error('Error loading chats:', error);
      toast.error('Failed to load chats');
    }
  }, []);
  

  const fetchMessages = useCallback(async (chatId) => {
    try {
      const response = await fetch(`/api/admin/chat/${chatId}/messages`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
        }
      });

      if (response.ok) {
        const data = await response.json();
        setMessages(data.messages);
        // Mark messages as seen
        fetch(`/api/admin/chat/${chatId}/seen`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
          }
        });
      }
    } catch (error) {
      console.error('Error fetching messages:', error);
      toast.error('Failed to load messages');
    }
  }, []);

  // Socket event handlers
  useEffect(() => {
    if (socket && admin) {
      socket.emit('joinAdminChat');
      
      socket.on('newMessage', ({ chatId, message, userId }) => {
        if (selectedChat?._id === chatId) {
          setMessages(prev => [...prev, message]);
          // Mark message as seen immediately if chat is open
          fetch(`/api/admin/chat/${chatId}/seen`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
            }
          });
        }
        setChats(prev =>
          prev.map(chat =>
            chat._id === chatId
              ? {
                  ...chat,
                  lastMessage: message.content,
                  lastMessageTime: message.createdAt,
                  unreadCount: selectedChat?._id === chatId ? 0 : chat.unreadCount + 1
                }
              : chat
          )
        );
      });

      socket.on('userTyping', ({ chatId, userId }) => {
        setTypingUsers(prev => new Set(prev).add(userId));
      });

      socket.on('userStopTyping', ({ chatId, userId }) => {
        setTypingUsers(prev => {
          const newSet = new Set(prev);
          newSet.delete(userId);
          return newSet;
        });
      });

      socket.on('userOnline', ({ userId }) => {
        setOnlineUsers(prev => new Set(prev).add(userId));
      });

      socket.on('userOffline', ({ userId }) => {
        setOnlineUsers(prev => {
          const newSet = new Set(prev);
          newSet.delete(userId);
          return newSet;
        });
      });

      fetchChats();
    }

    return () => {
      if (socket) {
        socket.off('newMessage');
        socket.off('userTyping');
        socket.off('userStopTyping');
        socket.off('userOnline');
        socket.off('userOffline');
      }
    };
  }, [socket, admin, selectedChat, fetchChats]);

  // Call fetchMessages when a ticket is selected
  useEffect(() => {
    if (selectedTicket) {
      fetchMessages(selectedTicket._id || selectedTicket);
    }
  }, [selectedTicket, fetchMessages]);

  // Run initial fetches after helpers are defined
  useEffect(() => {
    fetchAnalytics();
    fetchAgents();
    fetchTickets();

    // mobile detection
    const checkMobile = () => {
      const mobile = typeof window !== 'undefined' && window.innerWidth < 768;
      setIsMobile(mobile);
      setShowSidebar(!mobile);
    };
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, [fetchAnalytics, fetchAgents, fetchTickets]);

  const assignTicket = async (ticketId, agentId) => {
    try {
      const response = await fetch(`/api/admin/support/tickets/${ticketId}/assign`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
        },
        body: JSON.stringify({ agentId })
      });

      if (response.ok) {
        const data = await response.json();
        setTickets(tickets.map(t => t._id === ticketId ? data.ticket : t));
        if (selectedTicket?._id === ticketId) {
          setSelectedTicket(data.ticket);
        }
        toast.success('Ticket assigned successfully');
       } else {
         const error = await response.json();
         toast.error(error.message || 'Failed to assign ticket');
       }
     } catch (error) {
       console.error('Error assigning ticket:', error);
       toast.error('Failed to assign ticket');
    }
  };

  const updateTicketStatus = async (ticketId, status) => {
    try {
      const response = await fetch(`/api/admin/support/tickets/${ticketId}/status`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
        },
        body: JSON.stringify({ status })
      });

      if (response.ok) {
        const data = await response.json();
        setTickets(tickets.map(t => t._id === ticketId ? data.ticket : t));
        if (selectedTicket?._id === ticketId) {
          setSelectedTicket(data.ticket);
        }
        toast.success('Ticket status updated successfully');
       } else {
         const error = await response.json();
         toast.error(error.message || 'Failed to update status');
       }
     } catch (error) {
       console.error('Error updating status:', error);
       toast.error('Failed to update status');
    }
  };

  const sendMessage = async (e) => {
    e.preventDefault();
    if (!selectedChat || (!newMessage.trim() && attachments.length === 0)) return;

    setLoading(true);

    try {
      const formData = new FormData();
      formData.append('content', newMessage.trim());
      attachments.forEach(file => {
        formData.append('attachments', file);
      });

      const response = await fetch(`/api/admin/chat/${selectedChat._id}/message`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
        },
        body: formData
      });

      if (response.ok) {
        const { message } = await response.json();
        setMessages(prev => [...prev, message]);
        setNewMessage('');
        setAttachments([]);
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }

        // Update chat list
        setChats(prev =>
          prev.map(chat =>
            chat._id === selectedChat._id
              ? {
                  ...chat,
                  lastMessage: message.content,
                  lastMessageTime: message.createdAt
                }
              : chat
          )
        );
      } else {
        const error = await response.json();
        toast.error(error.message || 'Failed to send message');
      }
    } catch (error) {
      console.error('Error sending message:', error);
      toast.error('Failed to send message');
    } finally {
      setLoading(false);
    }
  };

  // Handle typing indicator
  const handleTyping = () => {
    if (selectedChat) {
      clearTimeout(typingTimeoutRef.current);
      socket.emit('adminTyping', {
        chatId: selectedChat._id,
        userId: selectedChat.user._id
      });
      typingTimeoutRef.current = setTimeout(() => {
        socket.emit('adminStopTyping', {
          chatId: selectedChat._id,
          userId: selectedChat.user._id
        });
      }, 1000);
    }
  };

  const handleFileSelect = (e) => {
    const files = Array.from(e.target.files);
    setAttachments([...attachments, ...files]);
  };

  const removeAttachment = (index) => {
    setAttachments(attachments.filter((_, i) => i !== index));
  };

  const getStatusColor = (status) => {
    const colors = {
      'open': '#007bff',
      'in_progress': '#ffc107',
      'waiting_for_customer': '#17a2b8',
      'resolved': '#28a745',
      'closed': '#6c757d'
    };
    return colors[status] || '#6c757d';
  };

  const getPriorityColor = (priority) => {
    const colors = {
      'low': '#28a745',
      'medium': '#ffc107',
      'high': '#fd7e14',
      'urgent': '#dc3545'
    };
    return colors[priority] || '#6c757d';
  };

  const formatDate = (date) => {
    return new Date(date).toLocaleString();
  };

  const formatFileSize = (bytes) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  return (
    <div className="admin-support-container">
      {/* Users sidebar */}
      <div className="users-sidebar">
        <div className="search-container">
          <input
            type="text"
            placeholder="Search users..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="search-input"
          />
        </div>
        <div className="users-list">
          {chats.filter(chat =>
            chat.user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
            chat.user.email.toLowerCase().includes(searchTerm.toLowerCase())
          ).map(chat => (
            <div
              key={chat._id}
              className={`user-item ${selectedChat?._id === chat._id ? 'selected' : ''}`}
              onClick={() => setSelectedChat(chat)}
            >
              <div className="user-info">
                <div className={`status-indicator ${onlineUsers.has(chat.user._id) ? 'online' : 'offline'}`} />
                <div className="user-details">
                  <div className="user-name">{chat.user.name}</div>
                  <div className="user-email">{chat.user.email}</div>
                  <div className="last-message">
                    {typingUsers.has(chat.user._id) ? (
                      <span className="typing">typing...</span>
                    ) : (
                      chat.lastMessage
                    )}
                  </div>
                </div>
                {chat.unreadCount > 0 && (
                  <div className="unread-count">{chat.unreadCount}</div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Chat area */}
      <div className="chat-area">
        {selectedChat ? (
          <>
            <div className="chat-header">
              <div className="selected-user-info">
                <h2>{selectedChat.user.name}</h2>
                <span className={`status ${onlineUsers.has(selectedChat.user._id) ? 'online' : 'offline'}`}>
                  {onlineUsers.has(selectedChat.user._id) ? 'Online' : 'Offline'}
                </span>
              </div>
              <button 
                onClick={() => {
                  fetch(`/api/admin/chat/${selectedChat._id}/end`, {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${localStorage.getItem('adminToken')}`
                    }
                  });
                  setSelectedChat(null);
                  setChats(chats.filter(c => c._id !== selectedChat._id));
                }} 
                className="end-chat-button"
              >
                End Chat
              </button>
            </div>

            <div className="messages-container">
              {messages.map((message, index) => (
                <div
                  key={index}
                  className={`message ${message.senderType === 'Admin' ? 'admin-message' : 'user-message'}`}
                >
                  <div className="message-content">
                    {message.content}
                    {message.attachments?.length > 0 && (
                      <div className="attachments">
                        {message.attachments.map((attachment, i) => (
                          <div key={i} className="attachment">
                            <a
                              href={`/api/admin/chat/attachments/${attachment.filename}`}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="attachment-link"
                            >
                              <AiOutlinePaperClip />
                              {attachment.originalName} ({formatFileSize(attachment.size)})
                            </a>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  {message.senderType === 'Admin' && (
                    <div className="message-status">
                      {message.seen ? <BsCheckAll /> : <BsCheck />}
                    </div>
                  )}
                </div>
              ))}
              {typingUsers.has(selectedChat.user._id) && (
                <div className="typing-indicator">
                  typing...
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

                          <div className="chat-input-container">
                <button
                  className="attachment-btn"
                  onClick={() => fileInputRef.current.click()}
                >
                  <AiOutlinePaperClip size={20} />
                </button>
                <input
                  type="file"
                  multiple
                  hidden
                  ref={fileInputRef}
                  onChange={handleFileChange}
                  accept="image/*,application/pdf"
                />
                <div className="message-input-wrapper">
                  <textarea
                    className="message-input"
                    placeholder="Type a message..."
                    value={newMessage}
                    onChange={handleInputChange}
                    onKeyDown={handleKeyPress}
                  />
                </div>
                <button
                  className="send-btn"
                  onClick={handleSendMessage}
                  disabled={!newMessage.trim() && !attachments.length}
                >
                  <AiOutlineSend size={20} />
                </button>
              </div>
          </>
        ) : (
          <div className="no-chat-selected">
            <h3>Select a user to start chatting</h3>
            <p>Choose a user from the list to view and respond to their messages.</p>
          </div>
        )}
      </div>
    </div>
  );
        <div className="analytics-cards">
          <div className="analytics-card">
            <div className="card-value">{analytics.totalTickets || 0}</div>
            <div className="card-label">Total Tickets</div>
          </div>
          <div className="analytics-card">
            <div className="card-value">{analytics.openTickets || 0}</div>
            <div className="card-label">Open Tickets</div>
          </div>
          <div className="analytics-card">
            <div className="card-value">{analytics.avgResponseTime || '0h'}</div>
            <div className="card-label">Avg Response</div>
          </div>
          <div className="analytics-card">
            <div className="card-value">{analytics.satisfactionRating || '0.0'}</div>
            <div className="card-label">Satisfaction</div>
          </div>
        </div>
      </div>

      {/* Filters */}
      <div className="filters-section">
        <div className="search-box">
          <input
            type="text"
            placeholder="Search tickets..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="search-input"
          />
        </div>
        <div className="filters">
          <select
            value={filters.status}
            onChange={(e) => setFilters({...filters, status: e.target.value})}
          >
            {statuses.map(status => (
              <option key={status.value} value={status.value}>{status.label}</option>
            ))}
          </select>
          <select
            value={filters.priority}
            onChange={(e) => setFilters({...filters, priority: e.target.value})}
          >
            {priorities.map(priority => (
              <option key={priority.value} value={priority.value}>{priority.label}</option>
            ))}
          </select>
          <select
            value={filters.category}
            onChange={(e) => setFilters({...filters, category: e.target.value})}
          >
            {categories.map(category => (
              <option key={category.value} value={category.value}>{category.label}</option>
            ))}
          </select>
          <select
            value={filters.assignedAgent}
            onChange={(e) => setFilters({...filters, assignedAgent: e.target.value})}
          >
            <option value="all">All Agents</option>
            <option value="unassigned">Unassigned</option>
            {agents.map(agent => (
              <option key={agent._id} value={agent._id}>
                {agent.userId?.firstName} {agent.userId?.lastName}
              </option>
            ))}
          </select>
        </div>
      </div>

      <div className="admin-support-content">
        {/* Tickets List */}
        {showSidebar && (
          <div className={`admin-tickets-sidebar ${isMobile ? 'mobile-overlay' : ''}`} style={isMobile ? { position: 'fixed', top: 0, left: 0, zIndex: 60, height: '100vh', overflow: 'auto' } : {}}>
            {isMobile && (
              <div style={{ display: 'flex', justifyContent: 'flex-end', padding: '0.5rem 1rem', borderBottom: '1px solid #e9ecef', background: '#fff' }}>
                <button onClick={() => setShowSidebar(false)} aria-label="Close tickets" className="p-2 rounded bg-gray-100">Close</button>
              </div>
            )}
          <div className="tickets-count">
            {tickets.length} ticket{tickets.length !== 1 ? 's' : ''}
          </div>
          <div className="admin-tickets-list">
            {tickets.length === 0 ? (
              <div className="no-tickets">
                <p>No tickets found</p>
              </div>
            ) : (
              tickets.map(ticket => (
                <div 
                  key={ticket._id}
                  className={`admin-ticket-item ${selectedTicket?._id === ticket._id ? 'active' : ''}`}
                  onClick={() => setSelectedTicket(ticket)}
                >
                  <div className="admin-ticket-header">
                    <span className="ticket-id">#{ticket.ticketId}</span>
                    <div className="ticket-badges">
                      <span 
                        className="priority-badge"
                        style={{ backgroundColor: getPriorityColor(ticket.priority) }}
                      >
                        {ticket.priority}
                      </span>
                      <span 
                        className="status-badge"
                        style={{ backgroundColor: getStatusColor(ticket.status) }}
                      >
                        {ticket.status.replace('_', ' ')}
                      </span>
                    </div>
                  </div>
                  <h4 className="admin-ticket-subject">{ticket.subject}</h4>
                  <div className="admin-ticket-meta">
                    <div className="ticket-user">
                      {ticket.userId?.firstName} {ticket.userId?.lastName}
                    </div>
                    <div className="ticket-category">{ticket.category}</div>
                    <div className="ticket-date">{formatDate(ticket.createdAt)}</div>
                    {ticket.assignedAgent && (
                      <div className="assigned-agent">
                        Assigned to: {ticket.assignedAgent.firstName} {ticket.assignedAgent.lastName}
                      </div>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
          </div>
        )}

        {/* Chat Area */}
        <div className="admin-chat-area">
          {selectedTicket ? (
            <>
              {/* Ticket Header */}
              <div className="admin-ticket-header-detail">
                <div className="ticket-info">
                  <h3>#{selectedTicket.ticketId} - {selectedTicket.subject}</h3>
                  <div className="ticket-user-info">
                    <strong>Customer:</strong> {selectedTicket.userId?.firstName} {selectedTicket.userId?.lastName} 
                    ({selectedTicket.userId?.email})
                  </div>
                  <div className="ticket-description">
                    {selectedTicket.description}
                  </div>
                </div>
                <div className="ticket-actions">
                  <div className="action-group">
                    <label>Status:</label>
                    <select
                      value={selectedTicket.status}
                      onChange={(e) => updateTicketStatus(selectedTicket._id, e.target.value)}
                    >
                      {statuses.slice(1).map(status => (
                        <option key={status.value} value={status.value}>{status.label}</option>
                      ))}
                    </select>
                  </div>
                  <div className="action-group">
                    <label>Assign to:</label>
                    <select
                      value={selectedTicket.assignedAgent?._id || ''}
                      onChange={(e) => assignTicket(selectedTicket._id, e.target.value)}
                    >
                      <option value="">Unassigned</option>
                      {agents.map(agent => (
                        <option key={agent._id} value={agent._id}>
                          {agent.userId?.firstName} {agent.userId?.lastName}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>
              </div>

              {/* Messages */}
              <div className="admin-messages-container">
                {messages.map(message => (
                  <div 
                    key={message._id}
                    className={`admin-message ${message.senderType === 'user' ? 'customer-message' : 'agent-message'}`}
                  >
                    <div className="admin-message-header">
                      <span className="sender">
                        {message.senderType === 'user' 
                          ? `${selectedTicket.userId?.firstName} ${selectedTicket.userId?.lastName}` 
                          : `${message.senderId?.firstName} ${message.senderId?.lastName} (Agent)`
                        }
                      </span>
                      <span className="timestamp">{formatDate(message.createdAt)}</span>
                    </div>
                    <div className="admin-message-content">
                      {message.content}
                      {message.attachments && message.attachments.length > 0 && (
                        <div className="admin-message-attachments">
                          {message.attachments.map(attachment => (
                            <div key={attachment._id} className="admin-attachment">
                              <a 
                                href={`/api/support/attachments/${attachment._id}/download`}
                                target="_blank"
                                rel="noopener noreferrer"
                                className="admin-attachment-link"
                              >
                                📎 {attachment.originalName} ({formatFileSize(attachment.size)})
                              </a>
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>

              {/* Message Input */}
              {selectedTicket.status !== 'closed' && (
                <form onSubmit={sendMessage} className="admin-message-form">
                  {attachments.length > 0 && (
                    <div className="admin-attachments-preview">
                      {attachments.map((file, index) => (
                        <div key={index} className="admin-attachment-preview">
                          <span>{file.name} ({formatFileSize(file.size)})</span>
                          <button 
                            type="button"
                            onClick={() => removeAttachment(index)}
                            className="remove-attachment"
                          >
                            ×
                          </button>
                        </div>
                      ))}
                    </div>
                  )}
                  <div className="admin-message-input-container">
                    <textarea
                      value={newMessage}
                      onChange={(e) => setNewMessage(e.target.value)}
                      placeholder="Type your response..."
                      className="admin-message-input"
                      rows="3"
                    />
                    <div className="admin-message-actions">
                      <input
                        type="file"
                        ref={fileInputRef}
                        onChange={handleFileSelect}
                        multiple
                        className="file-input"
                        accept="image/*,.pdf,.doc,.docx,.txt"
                      />
                      <button 
                        type="button"
                        onClick={() => fileInputRef.current?.click()}
                        className="btn btn-outline-secondary"
                      >
                        📎
                      </button>
                      <button 
                        type="submit"
                        disabled={loading || (!newMessage.trim() && attachments.length === 0)}
                        className="btn btn-primary"
                      >
                        {loading ? 'Sending...' : 'Send Response'}
                      </button>
                    </div>
                  </div>
                </form>
              )}
            </>
          ) : (
            <div className="no-chat-selected">
              <h2>Select a chat to start messaging</h2>
              <p>Choose a user from the list to view and respond to their messages.</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default AdminSupportChat;